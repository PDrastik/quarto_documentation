<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Penny and Kevin">
<meta name="dcterms.date" content="2024-05-14">

<title>Website Update Documentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="documentation_files/libs/clipboard/clipboard.min.js"></script>
<script src="documentation_files/libs/quarto-html/quarto.js"></script>
<script src="documentation_files/libs/quarto-html/popper.min.js"></script>
<script src="documentation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="documentation_files/libs/quarto-html/anchor.min.js"></script>
<link href="documentation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="documentation_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="documentation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="documentation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="documentation_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Website Update Documentation</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Penny and Kevin </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 14, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#requirements" id="toc-requirements">Requirements</a></li>
  <li><a href="#website-overview" id="toc-website-overview">Website overview</a></li>
  <li><a href="#workflow-overview" id="toc-workflow-overview">Workflow overview</a></li>
  <li><a href="#using-quarto-with-rstudio" id="toc-using-quarto-with-rstudio">Using Quarto with Rstudio</a></li>
  <li><a href="#using-quarto-with-jupyterlab" id="toc-using-quarto-with-jupyterlab">Using Quarto with Jupyterlab</a></li>
  <li><a href="#roadmap-for-future-improvements" id="toc-roadmap-for-future-improvements">Roadmap for future improvements</a></li>
  </ul>
</nav>
<section id="requirements" class="level3">
<h3 class="anchored" data-anchor-id="requirements">Requirements</h3>
<ul>
<li><p>Github account. Request access to the IFoA repository <a href="https://github.com/institute-and-faculty-of-actuaries/mlr-blog">here</a> for the blog and the MLRWP repository <a href="https://github.com/orgs/MLRWP/teams/mlrwp-book">here</a> for the book. There is a desktop version of Github; alternatively, you can download Git <a href="https://git-scm.com/downloads">here</a></p></li>
<li><p>Quarto. This is included with recent versions of Rstudio; if you do not already have Quarto it can be downloaded <a href="https://quarto.org/docs/get-started/">here</a></p></li>
<li><p>An IDE of your choice. The following documentation will cover Rstudio and Jupyterlab</p></li>
</ul>
</section>
<section id="website-overview" class="level3">
<h3 class="anchored" data-anchor-id="website-overview">Website overview</h3>
<p>The Machine Learning in Reserving Working Party online presence takes the form of a blog and an electronic book. Both are produced using Quarto, a markdown language which permits integration with code. The process for updating both resources follows the same steps, with the only difference being the Github repository that is used.</p>
<p>Both websites are hosted using Github Pages:</p>
<ul>
<li><p>A Github Page is a website hosted directly from a Github repository.</p></li>
<li><p>Both websites include <em>.github.io</em> in their URL, indicating that they are instances of Github Pages.</p></li>
<li><p>We do not use the conventional practice of creating <em>.html</em> files and uploading to a server.</p></li>
<li><p>Instead, whenever an update is made to the main branch of the associated Github repository, the website will automatically update.</p></li>
<li><p>The process for creating or editing pages of the website will automatically generate a set of relevant <em>.html</em> files, which can be found in the <em>docs</em> folder of the repository. Open this folder and load <em>index.html</em> or another file in a browser. The web page that is displayed is equivalent to the output that would be obtained upon rendering the associated Quarto file (<em>index.qmd</em>) from the main folder. These <em>.html</em> files can be edited independently of the Quarto documents, and if necessary could be uploaded to a server to create a website using the ‘traditional’ method.</p></li>
<li><p>Github Pages automatically detects <em>index.html</em> in the repository and uses it for the landing page of the website.</p></li>
</ul>
</section>
<section id="workflow-overview" class="level3">
<h3 class="anchored" data-anchor-id="workflow-overview">Workflow overview</h3>
<p>Following the Git paradigm, the website can be updated by</p>
<ol type="1">
<li><p>Cloning the Github repository to your computer.</p>
<p><code>git clone https://github.com/institute-and-faculty-of-actuaries/mlr-blog.git</code></p>
<p>All commands given in this section are intended to be used in Git, which can be accessed by opening the relevant folder on your computer, right-clicking and selecting ‘Open Git Bash here’.</p></li>
<li><p>Creating a new branch.</p>
<p><code>git branch new_branch_name</code></p></li>
<li><p>Editing or adding pages using Quarto (refer to the relevant section below depending on your choice of IDE)</p></li>
<li><p>Pushing changes back to the Github repository:</p>
<p><code>git add .</code></p>
<p>(The ‘.’ character will pick up everything in your current folder. If you have only edited/added a few files, you can name them directly instead)</p>
<p><code>git commit -m "added new blog post"</code></p>
<p>Write an informative commit message, as this will be visible to other users on the Github repository.</p>
<p><code>git push</code></p>
<p>This will upload the changes that you’ve made on your local machine to the Github repository, so that they are available to others.</p></li>
<li><p>Submitting a <a href="https://docs.github.com/en/pull-requests">pull request</a> on Github. If approved, the branch can be merged into main (then deleted), at which point the changes go live on the website.</p></li>
</ol>
</section>
<section id="using-quarto-with-rstudio" class="level3">
<h3 class="anchored" data-anchor-id="using-quarto-with-rstudio">Using Quarto with Rstudio</h3>
<ol type="1">
<li><p>Open a <em>.qmd</em> file from the repository or create a new Quarto Document using the Rstudio GUI. New blog posts should be saved in a folder (you should give it a suitable name), saved within the most appropriate folder category in <em>mlr-blog/post</em></p>
<p>The file can be named however you like.</p>
<p>Rstudio gives you the option of using a visual editor (‘Visual’) or editing the Quarto file, similar to markdown, directly (‘Source’). The visual editor provides a helpful interface for some common syntax e.g.&nbsp;bold typeface, bullet points, tables, however it is not a WYSIWYG editor and you will need to work with the Quarto markdown language.</p></li>
<li><p>For a blog post to be listed on the website, it must start with a section providing metadata in YAML format. Here is an example which demonstrates the range of tags which can be detected by the post listing page (tags can be added or removed by modifying <em>posts.qmd</em>):</p>
<pre><code>---
title: "Title of the Blog Post"
date: "2024-05-14"
author: ["Author's name"]
image: image_name.png
categories: 
  - research
  - R
description: "This is a short description of the blog post."
---</code></pre>
<p>This YAML section can also be used to format the document, for example, indicating whether a table of contents should be produced.</p>
<p>Note the (optional) ‘image’ section in the code block above. The image referenced here should be saved to the same folder as the Quarto document.</p></li>
<li><p>The ‘Render’ button in Rstudio will create a preview of your document within the ‘Viewer’ pane. Assuming that you are using the default output format (<em>.html</em>), rendering will also save a <em>.html</em> file which can be viewed in your browser. Sometimes the output differs between the Viewer pane and the browser, so you should verify using the <em>.html</em> file that your document is displayed as intended. Using the render tab, you can also navigate around the website as you would with a browser window.</p></li>
<li><p>Render <em>posts.qmd</em> from the main folder of the repository so that your new page is picked up by the automatic listing capabilities of the website. Note that <em>.html</em> files can be found in the <em>mlr-blog/docs</em> folder.</p>
<p>It is also possible to render a Quarto document by navigating to the Terminal pane, changing to the appropriate directory using</p>
<p><code>cd absolute_path_for_your_folder_name</code></p>
<p>and then running</p>
<p><code>quarto render filename.qmd</code></p></li>
</ol>
</section>
<section id="using-quarto-with-jupyterlab" class="level3">
<h3 class="anchored" data-anchor-id="using-quarto-with-jupyterlab">Using Quarto with Jupyterlab</h3>
<ol type="1">
<li><p>Open an existing <em>.ipynb</em> file or create a new Jupyter notebook. New blog posts should be saved in a folder (you should give it a suitable name), saved within the most appropriate folder category in <em>mlr-blog/post</em></p>
<p>The file can be named however you like.</p></li>
<li><p>For a blog post to be listed on the website, it must start with a section providing metadata in YAML format. Here is an example which demonstrates the range of tags which can be detected by the post listing page (tags can be added or removed by modifying <em>posts.qmd</em>):</p>
<pre><code>---
title: "Title of the Blog Post"
date: "2024-05-14"
author: ["Author's name"]
image: image_name.png
categories: 
  - research
  - python
description: "This is a short description of the blog post."
---</code></pre>
<p>This YAML section can also be used to format the document, for example, indicating whether a table of contents should be produced.</p>
<p>Note the (optional) ‘image’ section in the code block above. The image referenced here should be saved to the same folder as the Quarto document.</p>
<p>In a Jupyter notebook, this should be added as a raw or Raw NBConvert cell.</p></li>
<li><p>Render your document by opening a Terminal (in Jupyterlab: using the File menu). Run the following command:</p>
<p><code>quarto render file_name.ipynb</code></p></li>
<li><p>Render <em>posts.qmd</em> from the main folder of the repository so that your new page is picked up by the automatic listing capabilities of the website.</p>
<p>Assuming that you are using the default output format (<em>.html</em>), rendering your notebook will also save a <em>.html</em> file which can be viewed in your browser. This can be viewed in the <em>mlr-blog/docs</em> folder.</p></li>
</ol>
</section>
<section id="roadmap-for-future-improvements" class="level3">
<h3 class="anchored" data-anchor-id="roadmap-for-future-improvements">Roadmap for future improvements</h3>
<p><strong>Branch cleanup</strong>: Ideally, branches should be created for the purpose of a specific update and then deleted once the update has been approved and implemented. Here is a list of the branches that currently exist in the repository:</p>
<table class="table">
<thead>
<tr class="header">
<th>Branch name</th>
<th>Active?</th>
<th>Owner?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>main</td>
<td>Yes</td>
<td></td>
</tr>
<tr class="even">
<td>nn-april2024-revised</td>
<td>Unknown</td>
<td>Gráinne</td>
</tr>
<tr class="odd">
<td>mlrwp-sarah-patch-1</td>
<td>Unknown</td>
<td>Sarah</td>
</tr>
<tr class="even">
<td>nn-april2024</td>
<td>Unknown</td>
<td>Gráinne</td>
</tr>
<tr class="odd">
<td>test-nn-blog-v1</td>
<td>No?</td>
<td>Gráinne</td>
</tr>
</tbody>
</table>
<p><strong>User documentation:</strong> produce documentation to assist blog writers in producing compliant <em>.qmd</em> or <em>.ipynb</em> files. Consider simplifications to allow users to avoid use of Github/branching. Consider producing additional documentation to help users upskill in Quarto, for example, tutorials or boilerplate code demonstrating useful features.</p>
<p><strong>Package/dependency management</strong></p>
<p><strong>Explore possibility of .pdf output from Quarto</strong></p>
<p><strong>Improve formatting of website e.g.&nbsp;CSS</strong></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>